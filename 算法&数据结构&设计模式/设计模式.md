[TOC]

# 1. 普通工厂模式
# 2. 单例模式
定义：**确保类只有一个实例，并且提供一个全局访问点**
用途：**缓存、注册表设置、线程池**等只需要一个实例对象

经典的单例模式


```java
public class Singleton{
    private static Singleton uniqueInstance;
    public static Singleton getInstance(){
        return uniqueInstance;
    }
}
```
缺陷：在多线程下会出问题。因为单例模式有且只有一次创建对象。当在第一次创建实例时，多线程一块进入`getInstance()`方法，有可能造成会创造多个实例的情况

**解决办法**：
1. 在类加载时就创建实例
2. 使用`volatile`关键字，双重验证

```java
//类加载时就创建
public class Singleton1{
    private static Singleton uniqueInstance = new Singleton();
    public static Singleton getInstance(){
        return uniqueInstance;
    }
}

//双重验证
public class Singleton2{
    private volatile static Singleton uniqueInstance;
    private Singleton(){}
    public static Singleton getInstance(){
        //检查实例，如果不存在，则进入同步区块
        if(uniqueInstance == null){
            synchronized (Singleton2.class){
                //进入区块后，如果仍是null，才创建实例
                if(uniqueInstance == null){
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

# 3. 代理模式
## 3.1 静态代理
## 3.2 动态代理

**代理对象**需要实现`InvocationHandler`这个接口
当使用者使用代理对象所代理的接口中的方法的时候，这个调用信息会被传递给`InvocationHandler`的`invoke`方法。在`invoke`方法的参数中可以获取到代理对象、方法对应的`Method`对象和调用的实际参数。`invoke`方法的返回值被返回给使用者，这种方法类似于`AOP`.
```java

    @Test
    public static void main(String[] args){

    }
```