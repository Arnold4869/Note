[TOC]

# 1. 事务
## 特性ACID(原子性、一致性、隔离性、持久性)
- 原子性:要么成功，要么失败（成功则提交，失败则回滚）
- 一致性:指事务从一个一致的状态转换到另一个一致的状态，可分为**强一致性、弱一致性、最终一致性和单调一致性、会话一致性**
- 隔离性：**并发**事务互相影响的程度，常见的有**脏读、幻读、不可重复读**
- 持久性：事务提交后，对系统的影响是**永久**的
### 一致性
- 强一致性：读操作可以读到提交的更新操作
- 弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。
- 最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟、系统负载等。
- 单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值
- 会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的的最新值。

### 隔离性
并发事务之间互相影响的程度。可能会出现的问题有：
- **脏读**:事务 A 修改了一个数据，但未提交，事务 B 读到了事务 A 未提交的更新结果，如果事务 A 提交失败，事务 B 读到的就是脏数据
- **不可重复读**：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。
- **幻读**：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。

#### 事务的隔离级别
从低到高分别是：
- Read Uncommitted:一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生
- Read Committed:只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读
- Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
- Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。
