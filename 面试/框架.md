[TOC]

## 1. 事务
### 配置事务的传播特性

- `MANDATORY`：表示支持当前事务，如果当前没有事务，则抛出异常
- `NESTED`：表示支持事务嵌套，如果当前存在事务，则将当前事务嵌套存在的事务中。如果没有事务，则按 REQUIRED 执行。
- `REQUIRED`：表示支持当前事务,如果没有事务，则创建一个，如果有，直接使用。
- `NEVER`：不支持事务，如果当前有事务，则抛出异常
- `NOT_SUPPORTED`：不支持事务，如果当前有事务，则挂起当前事务。
- `REQUIRES_NEW`：每次都创建新的事务，如果当前有事务，则挂起当前事务。
- `SUPPORTS`：如果当前存在事务，则使用该事务，如果没有事务，不做任何处理。

## 2. 阻塞非阻塞与同步异步区别
“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
### 1.同步与异步
同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

### 2. 阻塞与非阻塞
阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

## 3. SpringMVC 与 Struts2 区别
1. `Struts2` 是**类级别**的拦截， 一个类对应一个 `request` 上下文，`SpringMVC` 是方法级别的拦截，一个方法对应一个 `request`上下文，而方法同时又跟一个 `url` 对应,所以说从架构本身上 `SpringMVC` 就容易实现 `restful url` ,而 `struts2` 的架构实现起来要费劲，因为 `Struts2` 中Action的一个方法可以对应一个 `url`，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。
2. 由上边原因，`SpringMVC` 的方法之间基本上独立的，独享 `request response` 数据，请求数据通过参数获取，处理结果通过 `ModelMap` 交回给框架，方法之间不共享变量，而 `Struts2` 搞的就比较乱，虽然方法之间也是独立的，但其所有 `Action` 变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个 `Action`，一个 `Action` 对象对应一个 `request` 上下文。
3. 由于 `Struts2` 需要针对每个 `request` 进行封装，把 `request` ，`session` 等 `servlet` 生命周期的变量封装成一个一个 `Map` ，供给每个 `Action` 使用，并保证线程安全，所以在原则上，是比较耗费内存的。
4. 拦截器实现机制上，`Struts2` 有以自己的 `interceptor` 机制，`SpringMVC` 用的是独立的 `AOP` 方式，这样导致 `Struts2` 的配置文件量还是比 `SpringMVC` 大。
5. **`SpringMVC` 的入口是 `servlet` ，而 `Struts2` 是 `filter` ，这就导致了二者的机制不同，这里就牵涉到 `servlet` 和 `filter` 的区别了。**
6. `SpringMVC` 集成了 `Ajax`，使用非常方便，只需一个注解 `@ResponseBody` 就可以实现，然后直接返回响应文本即可，而 `Struts2` 拦截器集成了 `Ajax`，在 `Action` 中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。
7. `SpringMVC`验证支持JSR303，处理起来相对更加灵活方便，而 `Struts2`验证比较繁琐
8. `Spring MVC` 和 `Spring` 是无缝的。从这个项目的管理和安全上也比 `Struts2` 高（当然 `Struts2` 也可以通过不同的目录结构和相关配置做到 `SpringMVC` 一样的效果，但是需要 `xml` 配置的地方不少）。
9. 设计思想上，`Struts2` 更加符合OOP的编程思想， `SpringMVC` 就比较谨慎，在 `servlet` 上扩展。
10. `SpringMVC` 开发效率和性能高于 `Struts2`。
11. `SpringMVC` 可以认为已经100%零配置。
