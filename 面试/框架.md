[TOC]
<!-- MarkdownTOC -->

- 1. 事务
    - 配置事务的传播特性
- 2. 阻塞非阻塞与同步异步区别
    - 1.同步与异步
    - 2. 阻塞与非阻塞
- 3. SpringMVC 与 Struts2 区别
- 2. Struts2 的访问流程
    - 1. Struts2 的访问流程
- 3. Mybatis
    - 1. Mybatis 动态 sql 语句
    - if
    - choose when otherwise
    - trim where set
    - foreach
    - bind
- 4 Spring
    - AOP

<!-- /MarkdownTOC -->


## 1. 事务
### 配置事务的传播特性

- `MANDATORY`：表示支持当前事务，如果当前没有事务，则抛出异常
- `NESTED`：表示支持事务嵌套，如果当前存在事务，则将当前事务嵌套存在的事务中。如果没有事务，则按 REQUIRED 执行。
- `REQUIRED`：表示支持当前事务,如果没有事务，则创建一个，如果有，直接使用。
- `NEVER`：不支持事务，如果当前有事务，则抛出异常
- `NOT_SUPPORTED`：不支持事务，如果当前有事务，则挂起当前事务。
- `REQUIRES_NEW`：每次都创建新的事务，如果当前有事务，则挂起当前事务。
- `SUPPORTS`：如果当前存在事务，则使用该事务，如果没有事务，不做任何处理。

## 2. 阻塞非阻塞与同步异步区别
“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
### 1.同步与异步
同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

### 2. 阻塞与非阻塞
阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

## 3. SpringMVC 与 Struts2 区别
1. Struts2 是**类级别**的拦截， 一个类对应一个 request 上下文，SpringMVC 是方法级别的拦截，一个方法对应一个 request上下文，而方法同时又跟一个 url 对应,所以说从架构本身上 SpringMVC 就容易实现 restful url ,而 struts2 的架构实现起来要费劲，因为 Struts2 中Action的一个方法可以对应一个 url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。
2. 由上边原因，SpringMVC 的方法之间基本上独立的，独享 request response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量，而 Struts2 搞的就比较乱，虽然方法之间也是独立的，但其所有 Action 变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个 Action，一个 Action 对象对应一个 request 上下文。
3. 由于 Struts2 需要针对每个 request 进行封装，把 request ，session 等 servlet 生命周期的变量封装成一个一个 Map ，供给每个 Action 使用，并保证线程安全，所以在原则上，是比较耗费内存的。
4. 拦截器实现机制上，Struts2 有以自己的 interceptor 机制，SpringMVC 用的是独立的 AOP 方式，这样导致 Struts2 的配置文件量还是比 SpringMVC 大。
5. **SpringMVC 的入口是 servlet ，而 Struts2 是 filter ，这就导致了二者的机制不同，这里就牵涉到 servlet 和 filter 的区别了。**
6. SpringMVC 集成了 Ajax，使用非常方便，只需一个注解 `@ResponseBody` 就可以实现，然后直接返回响应文本即可，而 Struts2 拦截器集成了 Ajax，在 Action 中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。
7. SpringMVC 验证支持JSR303，处理起来相对更加灵活方便，而 Struts2 验证比较繁琐
8. Spring MVC 和 Spring 是无缝的。从这个项目的管理和安全上也比 Struts2 高（当然 Struts2 也可以通过不同的目录结构和相关配置做到 SpringMVC 一样的效果，但是需要 xml 配置的地方不少）。
9. 设计思想上，Struts2 更加符合OOP的编程思想， SpringMVC 就比较谨慎，在 servlet 上扩展。
10. SpringMVC 开发效率和性能高于 Struts2。
11. SpringMVC 可以认为已经100%零配置。

## 2. Struts2 的访问流程
### 1. Struts2 的访问流程
![Struts2请求流程](https://github.com/Arnold4869/note/blob/master/images/clone01.png?raw=true  "Struts2请求流程")

1. 先初始化容器（启动服务器）
2. 请求先访问一系列的**过滤器**（Filter）
3. FilterDispatcher 被调用，FilterDispatcher 询问 ActionMapper 来决定是否调用某个 Action
4. 如果ActionMapper 决定需要调用某个Action ，
FilterDispatcher 把请求的处理交给ActionProxy
5. ActionProxy 通过 Configuration Manager 询问框架的配置文件**(Struts2.xml)**，
找到需要调用的 Action 类
6. ActionProxy 创建一个 ActionInvocation 的实例。
7. ActionInvocation 实例使用**命名模式**来调用，
在调用 Action 的过程前后，涉及到相关拦截器（ Intercepter ）的调用。
8. 一旦Action 执行完毕， ActionInvocation 负责根据 struts.xml 中的配置找到对应的返回结果。返回结果通常是（但不总是， 也可能是另外的一个 Action 链）一个需要被表示的 JSP 或者 FreeMarker 的模版。在表示的过程中可以使用 Struts2 框架中继承的标签。在这个过程中需要涉及到 ActionMapper
9. 响应的**返回**是通过我们在 web.xml 中配置的过滤器
10. 如果 ActionContextCleanUp 是当前使用的， 则 FilterDispatecher 将不会清理 sreadlocal ActionContext;
如果 ActionContextCleanUp 不使用，则将会去清理 sreadlocals

## 3. Mybatis

### 1. Mybatis 动态 sql 语句

**用于拼接 sql 语句**
- if
- choose when otherwise
- trim where set
- foreach
- bind

### if

```xml
<select id="findActiveBlogWithTitleLike" resultType="Blog">
        SELECT * FROM BLOG
    WHERE state = ‘ACTIVE’
    <if test="title != null">
        AND title like #{title}
    </if>
</select>
```

### choose when otherwise

```xml
<select id="findActiveBlogLike" resultType="Blog">
    SELECT * FROM BLOG WHERE state = ‘ACTIVE’
    <choose>
        <when test="title != null">
            AND title like #{title}
        </when>
        <when test="author != null and author.name != null">
            AND author_name like #{author.name}
        </when>
        <otherwise>
            AND featured = 1
        </otherwise>
    </choose>
</select>
```

### trim where set

```xml
<select id="findActiveBlogLike" resultType="Blog">
    SELECT * FROM BLOG
    <where>
    <if test="state != null">
         state = #{state}
    </if>
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
```
```xml
<trim prefix="SET" suffixOverrides=",">
  ...
</trim>
```

### foreach

```xml
<select id="selectPostIn" resultType="domain.blog.Post">
    SELECT *
    FROM POST P
    WHERE ID in
    <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
        #{item}
    </foreach>
</select>
```

### bind
bind 元素可以从OGNL表达式中**创建一个变量并绑定到上下文**

```xml
<select id="selectBlogsLike" resultType="Blog">
    <bind name="pattern" value="'%' + _parameter.getTitle() + '%'" />
    SELECT * FROM BLOG
    WHERE title LIKE #{pattern}
</select>
```
## 4 Spring
### AOP

#### 术语
连接点：是程序执行过程中**可以**应用通知的**所有点**

切点：用来筛选连接点，定义了**被应用**的所在位置，其实就是**实际被应用**的地方。**切点来筛选连接点，选中想要的方法**

通知：切面必须完成的工作被称之为通知,有五种(`Before`,`After`,`After-return`,`After-throwing`,`Around`)

切面：它是通知和切点的结合。通知和切点共同定义了关于切面的全部内容（它是什么，在何时，和何处完成其功能）。**切面就是切点和通知统称起来的东西。具体到了某个方法的某个位置（执行前或者执行后），要做什么事（具体的事情由通知定义）**

#### 编写切点
**切点需要在配置文件中声明。**

```
execution(* com.bjsxt.arnold.Student.play(..)
```