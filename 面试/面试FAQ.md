[TOC]
# SE
## 1. int 和 Integer 区别
1. 无论如何，`Integer`与`new Integer`不会相等。不会经历拆箱过程，i3的引用指向堆，而i4指向专门存放他的内存（常量池），他们的内存地址不一样，所以为`false`
2. 两个都是非**new**出来的`Integer`，如果数在`-128`到`127`之间，则是`true`,否则为`false`。原因是java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存
3. 两个都是**new**出来的,都为`false`
4. `int`和`integer`**(无论new否)**比，都为`true`，因为会把`Integer`自动拆箱为`int`再去比

## 2. String / StringBuffer / StringBuilder
`String`：不可变、不可继承
`StringBuffer`：可变，线程安全
`StringBuilder`:可变，线程不安全

在大部分情况下，字符串拼接速度：
`StringBuilder` > `StringBuffer` > `String`
具体参见[String/StringBuffer/StringBuilder](http://blog.csdn.net/rmn190/article/details/1492013)

# 框架相关
## 1. 事务
### 配置事务的传播特性

- `MANDATORY`：表示支持当前事务，如果当前没有事务，则抛出异常
- `NESTED`：表示支持事务嵌套，如果当前存在事务，则将当前事务嵌套存在的事务中。如果没有事务，则按 REQUIRED 执行。
- `REQUIRED`：表示支持当前事务,如果没有事务，则创建一个，如果有，直接使用。
- `NEVER`：不支持事务，如果当前有事务，则抛出异常
- `NOT_SUPPORTED`：不支持事务，如果当前有事务，则挂起当前事务。
- `REQUIRES_NEW`：每次都创建新的事务，如果当前有事务，则挂起当前事务。
- `SUPPORTS`：如果当前存在事务，则使用该事务，如果没有事务，不做任何处理。

## 2. 阻塞非阻塞与同步异步区别
“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
### 1.同步与异步
同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

### 2. 阻塞与非阻塞
阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。